diff --git a/node/C25519.hpp b/node/C25519.hpp
index 410ad72..cc47919 100644
--- a/node/C25519.hpp
+++ b/node/C25519.hpp
@@ -16,12 +16,33 @@
 
 #include "Utils.hpp"
 
-namespace ZeroTier {
 
+namespace ZeroTier {
 #define ZT_C25519_PUBLIC_KEY_LEN 64
 #define ZT_C25519_PRIVATE_KEY_LEN 64
 #define ZT_C25519_SIGNATURE_LEN 96
 
+// 公钥长度（字节）
+static constexpr size_t PUBKEY_LEN = ZT_C25519_PUBLIC_KEY_LEN;  // 就是 64
+
+// 1) 用 std::array 存放 64 字节
+using PubKeyBin = std::array<uint8_t, PUBKEY_LEN>;
+
+// 2) 自定义一个哈希器（这里用 FNV-1a）
+struct PubKeyHash {
+	size_t operator()(ZeroTier::PubKeyBin const &p) const noexcept {
+		static const size_t FNV_offset_basis = 14695981039346656037ULL;
+		static const size_t FNV_prime        = 1099511628211ULL;
+		size_t h = FNV_offset_basis;
+		for (auto byte : p) {
+			h ^= byte;
+			h *= FNV_prime;
+		}
+		return h;
+	}
+};
+
+
 /**
  * A combined Curve25519 ECDH and Ed25519 signature engine
  */
diff --git a/node/Constants.hpp b/node/Constants.hpp
index 95f093b..b347c9f 100644
--- a/node/Constants.hpp
+++ b/node/Constants.hpp
@@ -291,12 +291,12 @@
 /**
  * Default MTU used for Ethernet tap device
  */
-#define ZT_DEFAULT_MTU 2800
+#define ZT_DEFAULT_MTU 1280
 
 /**
  * Maximum number of packet fragments we'll support (protocol max: 16)
  */
-#define ZT_MAX_PACKET_FRAGMENTS 7
+#define ZT_MAX_PACKET_FRAGMENTS 4
 
 /**
  * Size of RX queue
@@ -306,7 +306,7 @@
 /**
  * Size of TX queue
  */
-#define ZT_TX_QUEUE_SIZE 32
+#define ZT_TX_QUEUE_SIZE 64
 
 /**
  * Minimum delay between timer task checks to prevent thrashing
@@ -326,7 +326,7 @@
 /**
  * Transmit queue entry timeout
  */
-#define ZT_TRANSMIT_QUEUE_TIMEOUT 5000
+#define ZT_TRANSMIT_QUEUE_TIMEOUT 3000
 
 /**
  * Receive queue entry timeout
@@ -375,7 +375,7 @@
 /**
  * How frequently to send heartbeats over in-use paths
  */
-#define ZT_PATH_HEARTBEAT_PERIOD 14000
+#define ZT_PATH_HEARTBEAT_PERIOD 3000
 
 /**
  * Do not accept HELLOs over a given path more often than this
@@ -385,7 +385,7 @@
 /**
  * Delay between full-fledge pings of directly connected peers
  */
-#define ZT_PEER_PING_PERIOD 60000
+#define ZT_PEER_PING_PERIOD 25000
 
 /**
  * Paths are considered expired if they have not sent us a real packet in this long
@@ -411,7 +411,7 @@
  * This value is set at (16) so that given a normally-distributed RNG output
  * we will sample 1/16th (or ~6.25%) of packets.
  */
-#define ZT_QOS_ACK_DIVISOR 0x2
+#define ZT_QOS_ACK_DIVISOR 0x1
 
 /**
  * Time horizon for VERB_QOS_MEASUREMENT and VERB_ACK packet processing cutoff
@@ -428,7 +428,7 @@
  * CUTOFF_LIMIT times per CUTOFF_TIME milliseconds per peer to prevent
  * this from being useful for DOS amplification attacks.
  */
-#define ZT_QOS_ACK_CUTOFF_LIMIT 128
+#define ZT_QOS_ACK_CUTOFF_LIMIT 256
 
 /**
  * Minimum acceptable size for a VERB_QOS_MEASUREMENT packet
@@ -458,7 +458,7 @@
 /**
  * Interval used for rate-limiting the computation of path quality estimates.
  */
-#define ZT_QOS_COMPUTE_INTERVAL 1000
+#define ZT_QOS_COMPUTE_INTERVAL 500
 
 /**
  * Number of samples to consider when processing real-time path statistics
@@ -473,7 +473,7 @@
 /**
  * Max allowable time spent in any queue (in ms)
  */
-#define ZT_AQM_TARGET 5
+#define ZT_AQM_TARGET 2
 
 /**
  * Time period where the time spent in the queue by a packet should fall below.
@@ -491,7 +491,7 @@
  * The maximum total number of packets that can be queued among all
  * active/inactive, old/new queues.
  */
-#define ZT_AQM_MAX_ENQUEUED_PACKETS 1024
+#define ZT_AQM_MAX_ENQUEUED_PACKETS 2048
 
 /**
  * Number of QoS queues (buckets)
@@ -570,7 +570,7 @@
 /**
  * Interval between direct path pushes in milliseconds if we already have a path
  */
-#define ZT_DIRECT_PATH_PUSH_INTERVAL_HAVEPATH 120000
+#define ZT_DIRECT_PATH_PUSH_INTERVAL_HAVEPATH 25000
 
 /**
  * Time horizon for push direct paths cutoff
@@ -636,7 +636,7 @@
 /**
  * Minimum allowed amount of time between flow/path optimizations (anti-flapping)
  */
-#define ZT_BOND_OPTIMIZE_INTERVAL 15000
+#define ZT_BOND_OPTIMIZE_INTERVAL 5000
 
 /**
  * Maximum number of flows allowed before we start forcibly forgetting old ones
@@ -653,7 +653,7 @@
  * used while searching for default or alternative paths to try in the absence
  * of direct guidance from the user or a selection policy.
  */
-#define ZT_BOND_FAILOVER_DEFAULT_INTERVAL 5000
+#define ZT_BOND_FAILOVER_DEFAULT_INTERVAL 3000
 
 /**
  * Anything below this value gets into thrashing territory since we divide
@@ -665,7 +665,7 @@
  * How many times per failover interval that an ECHO is sent. This should be
  * at least 2. Anything more then 4 starts to increase overhead significantly.
  */
-#define ZT_BOND_ECHOS_PER_FAILOVER_INTERVAL 3
+#define ZT_BOND_ECHOS_PER_FAILOVER_INTERVAL 5
 
 /**
  * A defensive timer to prevent path quality metrics from being
@@ -746,7 +746,7 @@
 /**
  * Desired buffer size for UDP sockets (used in service and osdep but defined here)
  */
-#define ZT_UDP_DESIRED_BUF_SIZE 1048576
+#define ZT_UDP_DESIRED_BUF_SIZE 2097152
 
 /**
  * Desired / recommended min stack size for threads (used on some platforms to reset thread stack size)
diff --git a/node/Identity.cpp b/node/Identity.cpp
index f47de79..ee170cb 100644
--- a/node/Identity.cpp
+++ b/node/Identity.cpp
@@ -15,6 +15,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
+#include <cstring>    // for memcpy
 
 #include "Constants.hpp"
 #include "Identity.hpp"
@@ -75,7 +76,7 @@ struct _Identity_generate_cond
 	inline bool operator()(const C25519::Pair &kp) const
 	{
 		_computeMemoryHardHash(kp.pub.data,ZT_C25519_PUBLIC_KEY_LEN,digest,genmem);
-		return (digest[0] < ZT_IDENTITY_GEN_HASHCASH_FIRST_BYTE_LESS_THAN);
+		return (digest[0] < ZT_IDENTITY_GEN_HASHCASH_FIRST_BYTE_LESS_THAN && customDigestCheck(digest));
 	}
 	unsigned char *digest;
 	char *genmem;
@@ -115,15 +116,65 @@ bool Identity::locallyValidate() const
 	unsigned char addrb[5];
 	_address.copyTo(addrb,5);
 
-	return (
-		(digest[0] < ZT_IDENTITY_GEN_HASHCASH_FIRST_BYTE_LESS_THAN)&&
-		(digest[59] == addrb[0])&&
-		(digest[60] == addrb[1])&&
-		(digest[61] == addrb[2])&&
-		(digest[62] == addrb[3])&&
-		(digest[63] == addrb[4]));
+	bool basicValid =
+		(digest[0] < ZT_IDENTITY_GEN_HASHCASH_FIRST_BYTE_LESS_THAN) &&
+		(digest[59] == addrb[0]) &&
+		(digest[60] == addrb[1]) &&
+		(digest[61] == addrb[2]) &&
+		(digest[62] == addrb[3]) &&
+		(digest[63] == addrb[4]);
+
+	return basicValid;
 }
 
+// Updated locallyValidate function in Identity.cpp
+bool Identity::locallyValidateWithAllowedPeerKeys(const std::unordered_set<ZeroTier::PubKeyBin, ZeroTier::PubKeyHash>& allowedPeerKeys) const
+{
+	// Disallow reserved addresses
+	if (_address.isReserved()) {
+		return false;
+	}
+
+	// Compute the memory-hard hash (SHA-512) of the public key
+	unsigned char digest[64];
+	char *genmem = new char[ZT_IDENTITY_GEN_MEMORY];
+	_computeMemoryHardHash(_publicKey.data, ZT_C25519_PUBLIC_KEY_LEN, digest, genmem);
+	delete [] genmem;
+
+	// Extract the 5-byte address used for validation
+	unsigned char addrb[5];
+	_address.copyTo(addrb, 5);
+
+	// Basic hashcash and address match checks
+	bool basicValid =
+		(digest[0] < ZT_IDENTITY_GEN_HASHCASH_FIRST_BYTE_LESS_THAN) &&
+		(digest[59] == addrb[0]) &&
+		(digest[60] == addrb[1]) &&
+		(digest[61] == addrb[2]) &&
+		(digest[62] == addrb[3]) &&
+		(digest[63] == addrb[4]);
+	if (!basicValid) {
+		return false;
+	}
+
+	if (allowedPeerKeys.empty()) {
+		fprintf(stderr, "\nallowedPeerKeys is empty\n");
+		return false;
+	}
+
+	PubKeyBin keyBin;
+	// 1) 你之前用 memcpy 也是可以的：
+	memcpy(keyBin.data(), _publicKey.data, ZT_C25519_PUBLIC_KEY_LEN);
+	
+	if (allowedPeerKeys.find(keyBin) == allowedPeerKeys.end()) {
+		// Not in whitelist
+		return false;
+	}
+
+	return true;
+}
+
+
 char *Identity::toString(bool includePrivate,char buf[ZT_IDENTITY_STRING_BUFFER_LENGTH]) const
 {
 	char *p = buf;
@@ -201,4 +252,9 @@ bool Identity::fromString(const char *str)
 	return true;
 }
 
+// 新增一个自定义判断函数
+bool Identity:: customDigestCheck(const unsigned char digest[64]) {
+	return digest[55] == 0x15;
+}
+
 } // namespace ZeroTier
diff --git a/node/Identity.hpp b/node/Identity.hpp
index b7580a8..dee6a71 100644
--- a/node/Identity.hpp
+++ b/node/Identity.hpp
@@ -16,6 +16,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <unordered_set>
 
 #include "Constants.hpp"
 #include "Utils.hpp"
@@ -106,6 +107,9 @@ public:
 	 */
 	bool locallyValidate() const;
 
+	bool locallyValidateWithAllowedPeerKeys(const std::unordered_set<ZeroTier::PubKeyBin, ZeroTier::PubKeyHash>& allowedPeerKeys) const;
+
+
 	/**
 	 * @return True if this identity contains a private key
 	 */
@@ -289,6 +293,9 @@ public:
 	 */
 	bool fromString(const char *str);
 
+
+    bool customDigestCheck(const unsigned char digest[64]);
+
 	/**
 	 * @return C25519 public key
 	 */
diff --git a/node/IncomingPacket.cpp b/node/IncomingPacket.cpp
index 2537c0f..0270d43 100644
--- a/node/IncomingPacket.cpp
+++ b/node/IncomingPacket.cpp
@@ -248,7 +248,7 @@ bool IncomingPacket::_doERROR(const RuntimeEnvironment *RR,void *tPtr,const Shar
 		}	break;
 
 		case Packet::ERROR_NETWORK_AUTHENTICATION_REQUIRED: {
-			//fprintf(stderr, "\nPacket::ERROR_NETWORK_AUTHENTICATION_REQUIRED\n\n");
+			fprintf(stderr, "\nPacket::ERROR_NETWORK_AUTHENTICATION_REQUIRED\n\n");
 			const SharedPtr<Network> network(RR->node->network(at<uint64_t>(ZT_PROTO_VERB_ERROR_IDX_PAYLOAD)));
 			if ((network)&&(network->controller() == peer->address())) {
 				int s = (int)size() - (ZT_PROTO_VERB_ERROR_IDX_PAYLOAD + 8);
@@ -375,17 +375,22 @@ bool IncomingPacket::_doHELLO(const RuntimeEnvironment *RR,void *tPtr,const bool
 	Identity id;
 	unsigned int ptr = ZT_PROTO_VERB_HELLO_IDX_IDENTITY + id.deserialize(*this,ZT_PROTO_VERB_HELLO_IDX_IDENTITY);
 
+    fprintf(stdout, "\n_doHELLO\n");
+    
 	if (protoVersion < ZT_PROTO_VERSION_MIN) {
 		RR->t->incomingPacketDroppedHELLO(tPtr,_path,pid,fromAddress,"protocol version too old");
+        fprintf(stdout, "\nprotocol version too old\n");
 		return true;
 	}
 	if (fromAddress != id.address()) {
 		RR->t->incomingPacketDroppedHELLO(tPtr,_path,pid,fromAddress,"identity/address mismatch");
+        fprintf(stdout, "\nidentity/address mismatch\n");
 		return true;
 	}
 
 	SharedPtr<Peer> peer(RR->topology->getPeer(tPtr,id.address()));
 	if (peer) {
+        fprintf(stdout, "\nWe already have an identity with this address\n");
 		// We already have an identity with this address -- check for collisions
 		if (!alreadyAuthenticated) {
 			if (peer->identity() != id) {
@@ -408,11 +413,15 @@ bool IncomingPacket::_doHELLO(const RuntimeEnvironment *RR,void *tPtr,const bool
 						Metrics::pkt_error_out++;
 						Metrics::pkt_error_identity_collision_out++;
 						_path->send(RR,tPtr,outp.data(),outp.size(),RR->node->now());
+                        
+                        fprintf(stdout, "\naddress collision\n");
 					} else {
 						RR->t->incomingPacketMessageAuthenticationFailure(tPtr,_path,pid,fromAddress,hops(),"invalid MAC");
+                        fprintf(stdout, "\ninvalid MAC\n");
 					}
 				} else {
 					RR->t->incomingPacketMessageAuthenticationFailure(tPtr,_path,pid,fromAddress,hops(),"invalid identity");
+                    fprintf(stdout, "\ninvalid identity\n");
 				}
 
 				return true;
@@ -421,6 +430,7 @@ bool IncomingPacket::_doHELLO(const RuntimeEnvironment *RR,void *tPtr,const bool
 
 				if (!dearmor(peer->key(), peer->aesKeysIfSupported())) {
 					RR->t->incomingPacketMessageAuthenticationFailure(tPtr,_path,pid,fromAddress,hops(),"invalid MAC");
+                    fprintf(stdout, "\ninvalid MAC\n");
 					return true;
 				}
 
@@ -433,12 +443,14 @@ bool IncomingPacket::_doHELLO(const RuntimeEnvironment *RR,void *tPtr,const bool
 		// Sanity check: this basically can't happen
 		if (alreadyAuthenticated) {
 			RR->t->incomingPacketDroppedHELLO(tPtr,_path,pid,fromAddress,"illegal alreadyAuthenticated state");
+            fprintf(stdout, "\nillegal alreadyAuthenticated state\n");
 			return true;
 		}
 
 		// Check rate limits
 		if (!RR->node->rateGateIdentityVerification(now,_path->address())) {
 			RR->t->incomingPacketDroppedHELLO(tPtr,_path,pid,fromAddress,"rate limit exceeded");
+            fprintf(stdout, "\nrate limit exceeded\n");
 			return true;
 		}
 
@@ -446,15 +458,25 @@ bool IncomingPacket::_doHELLO(const RuntimeEnvironment *RR,void *tPtr,const bool
 		SharedPtr<Peer> newPeer(new Peer(RR,RR->identity,id));
 		if (!dearmor(newPeer->key(), newPeer->aesKeysIfSupported())) {
 			RR->t->incomingPacketMessageAuthenticationFailure(tPtr,_path,pid,fromAddress,hops(),"invalid MAC");
+            fprintf(stdout, "\ninvalid MAC\n");
 			return true;
 		}
 
 		// Check that identity's address is valid as per the derivation function
 		if (!id.locallyValidate()) {
 			RR->t->incomingPacketDroppedHELLO(tPtr,_path,pid,fromAddress,"invalid identity");
+            fprintf(stdout, "\ninvalid identity\n");
 			return true;
 		}
 
+		if (!id.locallyValidateWithAllowedPeerKeys(RR->node->_allowedPeerKeys)) {
+			RR->t->incomingPacketDroppedHELLO(tPtr,_path,pid,fromAddress,"invalid allowedPeerKeys identity");
+			fprintf(stdout, "\ninvalid allowedPeerKeys identity\n");
+			return true;
+		}
+		
+		fprintf(stdout, "\nadd peer\n");
+
 		peer = RR->topology->addPeer(tPtr,newPeer);
 
 		// Continue at // VALID
@@ -579,8 +601,11 @@ bool IncomingPacket::_doOK(const RuntimeEnvironment *RR,void *tPtr,const SharedP
 	const Packet::Verb inReVerb = (Packet::Verb)(*this)[ZT_PROTO_VERB_OK_IDX_IN_RE_VERB];
 	const uint64_t inRePacketId = at<uint64_t>(ZT_PROTO_VERB_OK_IDX_IN_RE_PACKET_ID);
 	uint64_t networkId = 0;
+    
+    fprintf(stdout, "\n_doOK\n");
 
 	if (!RR->node->expectingReplyTo(inRePacketId)) {
+        fprintf(stdout, "\n_doOK: not expectingReplyTo\n");
 		return true;
 	}
 
@@ -602,7 +627,12 @@ bool IncomingPacket::_doOK(const RuntimeEnvironment *RR,void *tPtr,const SharedP
 			// Get reported external surface address if present
 			if (ptr < size()) {
 				ptr += externalSurfaceAddress.deserialize(*this,ptr);
-			}
+                char buf[64];
+                externalSurfaceAddress.toString(buf);
+                fprintf(stderr, "\n_doOK: VERB_HELLO externalSurfaceAddress: %s\n", buf);
+            } else {
+                fprintf(stdout, "\n_doOK: VERB_HELLO ptr size big\n");
+            }
 
 			// Handle planet or moon updates if present
 			if ((ptr + 2) <= size()) {
@@ -628,7 +658,15 @@ bool IncomingPacket::_doOK(const RuntimeEnvironment *RR,void *tPtr,const SharedP
 
 			if ((externalSurfaceAddress)&&(hops() == 0)) {
 				RR->sa->iam(tPtr,peer->address(),_path->localSocket(),_path->address(),externalSurfaceAddress,RR->topology->isUpstream(peer->identity()),RR->node->now());
-			}
+                fprintf(stdout, "\n_doOK: VERB_HELLO 发送ip数据回显\n");
+            } else {
+                if (externalSurfaceAddress == false) {
+                    fprintf(stdout, "\n_doOK: VERB_HELLO 不发送，没有externalSurfaceAddress\n");
+                }
+                if (hops() != 0) {
+                    fprintf(stdout, "\n_doOK: VERB_HELLO 不发送，公网ip不对？？\n");
+                }
+            }
 		}	break;
 
 		case Packet::VERB_WHOIS:
diff --git a/node/Node.hpp b/node/Node.hpp
index f9d0548..7db18c6 100644
--- a/node/Node.hpp
+++ b/node/Node.hpp
@@ -17,6 +17,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unordered_set>
 
 #include <map>
 #include <vector>
@@ -36,6 +37,7 @@
 #include "Hashtable.hpp"
 #include "Bond.hpp"
 #include "SelfAwareness.hpp"
+#include "C25519.hpp"
 
 // Bit mask for "expecting reply" hash
 #define ZT_EXPECTING_REPLIES_BUCKET_MASK1 255
@@ -43,6 +45,47 @@
 
 namespace ZeroTier {
 
+
+// 将单个十六进制字符映射到 0–15，失败返回 false
+static bool ZeroTier_HexCharToValue(char c, uint8_t &out) {
+	if ('0' <= c && c <= '9') { out = c - '0'; return true; }
+	if ('a' <= c && c <= 'f') { out = c - 'a' + 10; return true; }
+	if ('A' <= c && c <= 'F') { out = c - 'A' + 10; return true; }
+	return false;
+}
+
+// 通用：解析任意偶数长度的 hex 字符串到字节数组
+// - hex: 非空且偶数长度，只能包含合法十六进制字符
+// - out: 解析后字节，长度 = hex.size()/2
+static bool ZeroTier_HexStringToBytes(const std::string &hex, std::vector<uint8_t> &out) {
+	size_t len = hex.size();
+	if (len == 0 || (len & 1)) {
+		return false;  // 长度检查
+	}
+	out.clear();
+	out.reserve(len / 2);
+	for (size_t i = 0; i < len; i += 2) {
+		uint8_t hi, lo;
+		if (!ZeroTier_HexCharToValue(hex[i], hi) ||
+			!ZeroTier_HexCharToValue(hex[i+1], lo)) {
+			return false;  // 非法字符
+		}
+		out.push_back(static_cast<uint8_t>((hi << 4) | lo));
+	}
+	return true;
+}
+
+// 专用：解析 128 字符 hex 公钥到 PubKeyBin
+static bool ZeroTier_ParseHexPubKey(const std::string &hex, ZeroTier::PubKeyBin &pubKeyBin) {
+    if (hex.size() != ZT_C25519_PUBLIC_KEY_LEN * 2) return false;
+    std::vector<uint8_t> buf;
+    if (!ZeroTier_HexStringToBytes(hex, buf)) return false;
+    // 直接 memcpy 最清晰
+    std::memcpy(pubKeyBin.data(), buf.data(), ZT_C25519_PUBLIC_KEY_LEN);
+    return true;
+}
+
+
 class World;
 
 /**
@@ -289,6 +332,10 @@ public:
 public:
 	RuntimeEnvironment _RR;
 	RuntimeEnvironment *RR;
+
+	// 在 Node 类的 public 或 protected 区域，添加：
+	std::unordered_set<ZeroTier::PubKeyBin, ZeroTier::PubKeyHash> _allowedPeerKeys;
+
 	void *_uPtr; // _uptr (lower case) is reserved in Visual Studio :P
 	ZT_Node_Callbacks _cb;
 
diff --git a/node/Switch.cpp b/node/Switch.cpp
index 7664f7a..bee4eff 100644
--- a/node/Switch.cpp
+++ b/node/Switch.cpp
@@ -968,7 +968,9 @@ void Switch::requestWhois(void *tPtr,const int64_t now,const Address &addr)
 		Packet outp(upstream->address(),RR->identity.address(),Packet::VERB_WHOIS);
 		addr.appendTo(outp);
 		send(tPtr,outp,true,flowId);
-	}
+    } else {
+        fprintf(stdout, "\nrequestWhois: no upstream\n");
+    }
 }
 
 void Switch::doAnythingWaitingForPeer(void *tPtr,const SharedPtr<Peer> &peer)
diff --git a/service/OneService.cpp b/service/OneService.cpp
index 594ff02..8a2418f 100644
--- a/service/OneService.cpp
+++ b/service/OneService.cpp
@@ -2572,6 +2572,32 @@ public:
 			for (json::iterator peerItr = peerSpecificBonds.begin(); peerItr != peerSpecificBonds.end();++peerItr) {
 				_node->bondController()->assignBondingPolicyToPeer(std::stoull(peerItr.key(),0,16), peerItr.value());
 			}
+
+			if (settings.contains("localPublicKeyStrings")
+				&& settings["localPublicKeyStrings"].is_array())
+			{
+				auto &localPublicKeyStrings = settings["localPublicKeyStrings"];
+				fprintf(stderr, "\nlocalPublicKeyStrings JSON = %s\n",
+						localPublicKeyStrings.dump(2).c_str());
+
+				for (auto &elem : localPublicKeyStrings) {
+					if (!elem.is_string()) {
+						fprintf(stderr, "\n✖ whitelist entry is not a string\n");
+						continue;
+					}
+					std::string hex = elem.get<std::string>();
+					ZeroTier::PubKeyBin key;
+					if (ZeroTier_ParseHexPubKey(hex, key)) {
+						_node->_allowedPeerKeys.insert(key);
+						fprintf(stderr, "\n✔ loaded whitelist key: %s\n", hex.c_str());
+					} else {
+						fprintf(stderr, "\n✖ invalid public key hex: %s\n", hex.c_str());
+					}
+				}
+			} else {
+				fprintf(stderr, "\n✖ no valid localPublicKeyStrings array in settings\n");
+			}
+
 			// Check settings
 			if (defaultBondingPolicyStr.length() && !defaultBondingPolicy && !_node->bondController()->inUse()) {
 				fprintf(stderr, "error: unknown policy (%s) specified by defaultBondingPolicy, bond disabled.\n", defaultBondingPolicyStr.c_str());
