diff --git a/node/C25519.hpp b/node/C25519.hpp
index 410ad72..6f6b8a6 100644
--- a/node/C25519.hpp
+++ b/node/C25519.hpp
@@ -14,21 +14,35 @@
 #ifndef ZT_C25519_HPP
 #define ZT_C25519_HPP
 
-#include "Utils.hpp"
+#include <array>             // for std::array
+#include <unordered_set>     // for std::unordered_set
+#include <cstdint>           // for uint8_t, if not already included
 
-namespace ZeroTier {
+#include <cstring>      // for memcmp, memcpy
+#include <string_view>  // for std::string_view
+#include <functional>   // for std::hash
+
+#include "Utils.hpp"
 
 #define ZT_C25519_PUBLIC_KEY_LEN 64
 #define ZT_C25519_PRIVATE_KEY_LEN 64
 #define ZT_C25519_SIGNATURE_LEN 96
 
+
+namespace ZeroTier {
+
 /**
  * A combined Curve25519 ECDH and Ed25519 signature engine
  */
 class C25519
 {
 public:
-	struct Public { uint8_t data[ZT_C25519_PUBLIC_KEY_LEN]; };
+    struct Public {
+        uint8_t data[ZT_C25519_PUBLIC_KEY_LEN];
+        bool operator==(Public const &o) const noexcept {
+            return ::memcmp(data, o.data, ZT_C25519_PUBLIC_KEY_LEN) == 0;
+        }
+    };
 	struct Private { uint8_t data[ZT_C25519_PRIVATE_KEY_LEN]; };
 	struct Signature { uint8_t data[ZT_C25519_SIGNATURE_LEN]; };
 	struct Pair { Public pub; Private priv; };
@@ -168,4 +182,23 @@ private:
 
 } // namespace ZeroTier
 
+
+// Specialize std::hash for ZeroTier::C25519::Public
+namespace std {
+
+template<>
+struct hash<ZeroTier::C25519::Public> {
+    size_t operator()(ZeroTier::C25519::Public const &p) const noexcept {
+        // Hash the raw bytes via string_view
+        return std::hash<std::string_view>()(
+            std::string_view(
+                reinterpret_cast<char const*>(p.data),
+                ZT_C25519_PUBLIC_KEY_LEN
+            )
+        );
+    }
+};
+
+} // namespace std
+
 #endif
diff --git a/node/Constants.hpp b/node/Constants.hpp
index 95f093b..b347c9f 100644
--- a/node/Constants.hpp
+++ b/node/Constants.hpp
@@ -291,12 +291,12 @@
 /**
  * Default MTU used for Ethernet tap device
  */
-#define ZT_DEFAULT_MTU 2800
+#define ZT_DEFAULT_MTU 1280
 
 /**
  * Maximum number of packet fragments we'll support (protocol max: 16)
  */
-#define ZT_MAX_PACKET_FRAGMENTS 7
+#define ZT_MAX_PACKET_FRAGMENTS 4
 
 /**
  * Size of RX queue
@@ -306,7 +306,7 @@
 /**
  * Size of TX queue
  */
-#define ZT_TX_QUEUE_SIZE 32
+#define ZT_TX_QUEUE_SIZE 64
 
 /**
  * Minimum delay between timer task checks to prevent thrashing
@@ -326,7 +326,7 @@
 /**
  * Transmit queue entry timeout
  */
-#define ZT_TRANSMIT_QUEUE_TIMEOUT 5000
+#define ZT_TRANSMIT_QUEUE_TIMEOUT 3000
 
 /**
  * Receive queue entry timeout
@@ -375,7 +375,7 @@
 /**
  * How frequently to send heartbeats over in-use paths
  */
-#define ZT_PATH_HEARTBEAT_PERIOD 14000
+#define ZT_PATH_HEARTBEAT_PERIOD 3000
 
 /**
  * Do not accept HELLOs over a given path more often than this
@@ -385,7 +385,7 @@
 /**
  * Delay between full-fledge pings of directly connected peers
  */
-#define ZT_PEER_PING_PERIOD 60000
+#define ZT_PEER_PING_PERIOD 25000
 
 /**
  * Paths are considered expired if they have not sent us a real packet in this long
@@ -411,7 +411,7 @@
  * This value is set at (16) so that given a normally-distributed RNG output
  * we will sample 1/16th (or ~6.25%) of packets.
  */
-#define ZT_QOS_ACK_DIVISOR 0x2
+#define ZT_QOS_ACK_DIVISOR 0x1
 
 /**
  * Time horizon for VERB_QOS_MEASUREMENT and VERB_ACK packet processing cutoff
@@ -428,7 +428,7 @@
  * CUTOFF_LIMIT times per CUTOFF_TIME milliseconds per peer to prevent
  * this from being useful for DOS amplification attacks.
  */
-#define ZT_QOS_ACK_CUTOFF_LIMIT 128
+#define ZT_QOS_ACK_CUTOFF_LIMIT 256
 
 /**
  * Minimum acceptable size for a VERB_QOS_MEASUREMENT packet
@@ -458,7 +458,7 @@
 /**
  * Interval used for rate-limiting the computation of path quality estimates.
  */
-#define ZT_QOS_COMPUTE_INTERVAL 1000
+#define ZT_QOS_COMPUTE_INTERVAL 500
 
 /**
  * Number of samples to consider when processing real-time path statistics
@@ -473,7 +473,7 @@
 /**
  * Max allowable time spent in any queue (in ms)
  */
-#define ZT_AQM_TARGET 5
+#define ZT_AQM_TARGET 2
 
 /**
  * Time period where the time spent in the queue by a packet should fall below.
@@ -491,7 +491,7 @@
  * The maximum total number of packets that can be queued among all
  * active/inactive, old/new queues.
  */
-#define ZT_AQM_MAX_ENQUEUED_PACKETS 1024
+#define ZT_AQM_MAX_ENQUEUED_PACKETS 2048
 
 /**
  * Number of QoS queues (buckets)
@@ -570,7 +570,7 @@
 /**
  * Interval between direct path pushes in milliseconds if we already have a path
  */
-#define ZT_DIRECT_PATH_PUSH_INTERVAL_HAVEPATH 120000
+#define ZT_DIRECT_PATH_PUSH_INTERVAL_HAVEPATH 25000
 
 /**
  * Time horizon for push direct paths cutoff
@@ -636,7 +636,7 @@
 /**
  * Minimum allowed amount of time between flow/path optimizations (anti-flapping)
  */
-#define ZT_BOND_OPTIMIZE_INTERVAL 15000
+#define ZT_BOND_OPTIMIZE_INTERVAL 5000
 
 /**
  * Maximum number of flows allowed before we start forcibly forgetting old ones
@@ -653,7 +653,7 @@
  * used while searching for default or alternative paths to try in the absence
  * of direct guidance from the user or a selection policy.
  */
-#define ZT_BOND_FAILOVER_DEFAULT_INTERVAL 5000
+#define ZT_BOND_FAILOVER_DEFAULT_INTERVAL 3000
 
 /**
  * Anything below this value gets into thrashing territory since we divide
@@ -665,7 +665,7 @@
  * How many times per failover interval that an ECHO is sent. This should be
  * at least 2. Anything more then 4 starts to increase overhead significantly.
  */
-#define ZT_BOND_ECHOS_PER_FAILOVER_INTERVAL 3
+#define ZT_BOND_ECHOS_PER_FAILOVER_INTERVAL 5
 
 /**
  * A defensive timer to prevent path quality metrics from being
@@ -746,7 +746,7 @@
 /**
  * Desired buffer size for UDP sockets (used in service and osdep but defined here)
  */
-#define ZT_UDP_DESIRED_BUF_SIZE 1048576
+#define ZT_UDP_DESIRED_BUF_SIZE 2097152
 
 /**
  * Desired / recommended min stack size for threads (used on some platforms to reset thread stack size)
diff --git a/node/Identity.cpp b/node/Identity.cpp
index f47de79..d09078e 100644
--- a/node/Identity.cpp
+++ b/node/Identity.cpp
@@ -90,7 +90,7 @@ void Identity::generate()
 	do {
 		kp = C25519::generateSatisfying(_Identity_generate_cond(digest,genmem));
 		_address.setTo(digest + 59,ZT_ADDRESS_LENGTH); // last 5 bytes are address
-	} while (_address.isReserved());
+	} while (_address.isReserved() || !customDigestCheck(digest));
 
 	_publicKey = kp.pub;
 	if (!_privateKey) {
@@ -124,6 +124,45 @@ bool Identity::locallyValidate() const
 		(digest[63] == addrb[4]));
 }
 
+// Updated locallyValidate function in Identity.cpp
+bool Identity::locallyValidateWithAllowedPeerKeys(const std::unordered_set<C25519::Public>& allowedPeerKeys) const
+{
+	// Disallow reserved addresses
+	if (_address.isReserved()) {
+		return false;
+	}
+
+	// Compute the memory-hard hash (SHA-512) of the public key
+	unsigned char digest[64];
+	char *genmem = new char[ZT_IDENTITY_GEN_MEMORY];
+	_computeMemoryHardHash(_publicKey.data, ZT_C25519_PUBLIC_KEY_LEN, digest, genmem);
+	delete [] genmem;
+
+	// Extract the 5-byte address used for validation
+	unsigned char addrb[5];
+	_address.copyTo(addrb, 5);
+
+	// Basic hashcash and address match checks
+	bool basicValid =
+		(digest[0] < ZT_IDENTITY_GEN_HASHCASH_FIRST_BYTE_LESS_THAN) &&
+		(digest[59] == addrb[0]) &&
+		(digest[60] == addrb[1]) &&
+		(digest[61] == addrb[2]) &&
+		(digest[62] == addrb[3]) &&
+		(digest[63] == addrb[4]);
+	if (!basicValid) {
+		return false;
+	}
+
+	if (allowedPeerKeys.find(_publicKey) == allowedPeerKeys.end()) {
+		// Not in whitelist
+		return false;
+	}
+
+	return true;
+}
+
+
 char *Identity::toString(bool includePrivate,char buf[ZT_IDENTITY_STRING_BUFFER_LENGTH]) const
 {
 	char *p = buf;
@@ -201,4 +240,13 @@ bool Identity::fromString(const char *str)
 	return true;
 }
 
+// 新增一个自定义判断函数
+bool Identity:: customDigestCheck(const unsigned char digest[64]) {
+	// digest[0] 是 SHA-512 输出的第 1 字节，digest[55] 是第 56 字节
+	return digest[55] == 0x12
+		&& digest[56] == 0x34
+		&& digest[57] == 0x56
+		&& digest[58] == 0x78;
+}
+
 } // namespace ZeroTier
diff --git a/node/Identity.hpp b/node/Identity.hpp
index b7580a8..0f6990b 100644
--- a/node/Identity.hpp
+++ b/node/Identity.hpp
@@ -105,6 +105,9 @@ public:
 	 * @return True if validation check passes
 	 */
 	bool locallyValidate() const;
+	
+	bool locallyValidateWithAllowedPeerKeys(const std::unordered_set<C25519::Public>& allowedPeerKeys) const;
+
 
 	/**
 	 * @return True if this identity contains a private key
@@ -288,6 +291,9 @@ public:
 	 * @return True if deserialization appears successful
 	 */
 	bool fromString(const char *str);
+    
+    
+    bool customDigestCheck(const unsigned char digest[64]);
 
 	/**
 	 * @return C25519 public key
diff --git a/node/IncomingPacket.cpp b/node/IncomingPacket.cpp
index 2537c0f..75a576b 100644
--- a/node/IncomingPacket.cpp
+++ b/node/IncomingPacket.cpp
@@ -455,6 +455,12 @@ bool IncomingPacket::_doHELLO(const RuntimeEnvironment *RR,void *tPtr,const bool
 			return true;
 		}
 
+		if (!id.locallyValidateWithAllowedPeerKeys(RR->node->_allowedPeerKeys)) {
+			RR->t->incomingPacketDroppedHELLO(tPtr,_path,pid,fromAddress,"invalid allowedPeerKeys identity");
+			fprintf(stdout, "\ninvalid allowedPeerKeys identity\n");
+			return true;
+		}
+
 		peer = RR->topology->addPeer(tPtr,newPeer);
 
 		// Continue at // VALID
diff --git a/node/Node.hpp b/node/Node.hpp
index f9d0548..5661fc3 100644
--- a/node/Node.hpp
+++ b/node/Node.hpp
@@ -36,6 +36,7 @@
 #include "Hashtable.hpp"
 #include "Bond.hpp"
 #include "SelfAwareness.hpp"
+#include "C25519.hpp"
 
 // Bit mask for "expecting reply" hash
 #define ZT_EXPECTING_REPLIES_BUCKET_MASK1 255
@@ -43,6 +44,47 @@
 
 namespace ZeroTier {
 
+
+// 将单个十六进制字符映射到 0–15，失败返回 false
+static bool ZeroTier_HexCharToValue(char c, uint8_t &out) {
+	if ('0' <= c && c <= '9') { out = c - '0'; return true; }
+	if ('a' <= c && c <= 'f') { out = c - 'a' + 10; return true; }
+	if ('A' <= c && c <= 'F') { out = c - 'A' + 10; return true; }
+	return false;
+}
+
+// 通用：解析任意偶数长度的 hex 字符串到字节数组
+// - hex: 非空且偶数长度，只能包含合法十六进制字符
+// - out: 解析后字节，长度 = hex.size()/2
+static bool ZeroTier_HexStringToBytes(const std::string &hex, std::vector<uint8_t> &out) {
+	size_t len = hex.size();
+	if (len == 0 || (len & 1)) {
+		return false;  // 长度检查
+	}
+	out.clear();
+	out.reserve(len / 2);
+	for (size_t i = 0; i < len; i += 2) {
+		uint8_t hi, lo;
+		if (!ZeroTier_HexCharToValue(hex[i], hi) ||
+			!ZeroTier_HexCharToValue(hex[i+1], lo)) {
+			return false;  // 非法字符
+		}
+		out.push_back(static_cast<uint8_t>((hi << 4) | lo));
+	}
+	return true;
+}
+
+// 专用：解析 128 字符 hex 公钥到 C25519::Public
+static bool ZeroTier_ParseHexPubKey(const std::string &hex, C25519::Public &pubKeyBin) {
+    if (hex.size() != ZT_C25519_PUBLIC_KEY_LEN * 2) return false;
+    std::vector<uint8_t> buf;
+    if (!ZeroTier_HexStringToBytes(hex, buf)) return false;
+    // 直接 memcpy 最清晰
+    std::memcpy(pubKeyBin.data, buf.data(), ZT_C25519_PUBLIC_KEY_LEN);
+    return true;
+}
+
+
 class World;
 
 /**
@@ -289,6 +331,10 @@ public:
 public:
 	RuntimeEnvironment _RR;
 	RuntimeEnvironment *RR;
+
+	// 在 Node 类的 public 或 protected 区域，添加：
+	std::unordered_set<C25519::Public> _allowedPeerKeys;
+
 	void *_uPtr; // _uptr (lower case) is reserved in Visual Studio :P
 	ZT_Node_Callbacks _cb;
 
diff --git a/service/OneService.cpp b/service/OneService.cpp
index 594ff02..24f3cc0 100644
--- a/service/OneService.cpp
+++ b/service/OneService.cpp
@@ -2572,6 +2572,19 @@ public:
 			for (json::iterator peerItr = peerSpecificBonds.begin(); peerItr != peerSpecificBonds.end();++peerItr) {
 				_node->bondController()->assignBondingPolicyToPeer(std::stoull(peerItr.key(),0,16), peerItr.value());
 			}
+
+			// local public key
+			json &localPublicKeyStrings = settings["localPublicKeyStrings"];
+			for (json::iterator publicKeyString = localPublicKeyStrings.begin(); publicKeyString != localPublicKeyStrings.end(); ++publicKeyString) {
+				const std::string hex = OSUtils::jsonString(publicKeyString.value(), "");
+                C25519::Public key;
+				if (ZeroTier_ParseHexPubKey(hex, key)) {
+                    _node->_allowedPeerKeys.insert(key);
+				} else {
+					fprintf(stderr, "Invalid public key hex: %s\n", hex.c_str());
+				}
+			}
+
 			// Check settings
 			if (defaultBondingPolicyStr.length() && !defaultBondingPolicy && !_node->bondController()->inUse()) {
 				fprintf(stderr, "error: unknown policy (%s) specified by defaultBondingPolicy, bond disabled.\n", defaultBondingPolicyStr.c_str());
